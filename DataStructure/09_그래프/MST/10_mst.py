'''
프림알고리즘의 기본구현
인접 배열을 사용했지만
시간을 줄이고 싶다면, 인접리스트와 우선순위큐를 활용할수도 있다.

'''
# 인접행렬로 푼 문제
V, E = map(int, input().split())
adj = [[0] * V for _ in range(E)]
for i in range(E):
    s, e, c = map(int, input().split())
    adj[s][e] = c
    adj[e][s] = c

INF = float('inf')  # 무한
key = [INF] * V  # 각각의 노드 사이에서 최소 가중치 값이 있음
p = [-1] * V  # 각각 객체에는 before 노드번호 있음
mst = [False] * V  # 시작점이 다른 정점으로 이동을 했냐?? 의 유무

key[0] = 0
cnt = 0
result = 0  # 모든 가중치의 합
while cnt < V:
    min = INF
    u = -1
    ############################################################
    # 인접 정점중 가중치값이 있는 key 배열에서 가장 작은 min값을 찾은뒤
    # 해당 노드번호로 이동을 위한 u를 정의
    ############################################################
    for i in range(V):
        if not mst[i] and key[i] < min:
            min = key[i]
            u = i

    ############################################################
    # 이동한 정점의 방문표시를 위한 true를 하고 result에 가중치를 더해준다
    ############################################################
    mst[u] = True  # 이동한 정점인 u가 방문했음을 표시
    result += min
    cnt += 1

    ############################################################
    # 이동한 정점에서의 인접정점의 가중치(key)를 모두 저장시키고,
    # 기존의 저장되있던 가중치보다 작을경우에도 다시 갱신을 한다,
    # adj[u][w] > 0 : 인접행렬이 있고
    # not mst[w]    : 방문를 하지 않고
    # key[w] > adj[u][w] : 기존의 저장된 가중치보다 작을경우에만
    # 해당 인접 정점에 가중치를 저장하고 현재 위치 표시(p)를 한다.
    # 주의!! 이동을 한것은 아니다!! 임시로 저장해둔것!!
    ############################################################
    for w in range(V):
        if adj[u][w] > 0 and not mst[w] and key[w] > adj[u][w]:
            key[w] = adj[u][w]
            p[w] = u
print(key)  # 노드간의 가중치
print(p)  # p배열의 각각의 현재 위치 index에 있는 숫자가 현재위치 이전의 노드번호
print(mst)  # 방문배열
print(result)  # 최단거리를의 가중치의 합