# 백트래킹의 아주 정석적인 문제 n_queen
def backtrack(idx): # idx = 행
    global n,cnt
    if idx == n:
        # idx = 행과 같다 ==> 해를 다 찾음
        cnt +=1
        return
    # 해당 상태에서 선택할 수 있는 후보군 생성
    # 노드가 유망한지 확인 : 유망한 열 ,,
    for j in range(n):  # j 는 열을 의미, idx는 행
        # if 열이 유망하고, 상향대각, 하향대각들이 유망(사용하지 않아야함)
        if not col[j] and not dia_1[idx+j] and not dia_2[n+j-idx-1]:    # 유명성을 판단
            # 유망하다면 해당 위치의 열,대각선2개를 방문표시한다
            # 모든 후보군들에 대해 다음상태 실행
            col[j] =1
            dia_1[idx + j] =1
            dia_2[n + j - idx - 1] =1
            # 방문표시 한뒤 다음선택 진행
            backtrack(idx+1)    # 해당 자손들을 모두 탐색한뒤 다음 형제로 가기위해 열, 대각들을 0으로 재정의
                                # ex) 3,3를 찍고 해당 자손들을 다 확인하면 다음 형제 위치로 가기 위해
                                # 3,3으로 인해 자손들 위치로 이동한 흔적은 전부 0으로 다시 정의한다.
            col[j] =0
            dia_1[idx + j] =0
            dia_2[n + j - idx - 1] =0

n = 4
# 각행에는 1개의 퀸만 올수있음
col = [0]* n    # 열의 사용 여부
# 대각 유명성을 판단할 리스트
# 대각의 갯수파악 : 2 * n - 1
# 상향 대각(왼밑 -> 오른위) : 특징 idx,j의 합이 같음
dia_1 = [0] * (2 * n - 1) # i+j
# 하향 대각(왼위 -> 오른아래) : 특징 idx와 k의 차가 일정
dia_2 = [0]*(2 * n - 1) # n+j-i-1
cnt = 0
backtrack(0)
print(cnt)